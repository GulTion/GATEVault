{"path":"Revision/PYQ/FULL/media/Pasted image 20231103204109.png","text":"Ly ={(M) | L(M) = 2} « L is emptiness problem and is non-trivial because we can have two Turing machines M; and M with L(My) = @ and L(M,) = {0} (something non-empty). » So, Ly is undecidable. L = {(M) | L(M) is not recursive} « Lj s also describing a non-trivial property (of the language of Turing machines) as the language of not all the Turing machines is recursive. For example, we can have a Turing machine for halting problem and its language is recursively enumerable but not recursive. Ly = {(M) | L(M)contains at least 21 members} o Ly is also describing a non-trivial property as we can have two Turing machines M7 and My with say L(M;) = {0} and L(M3) = {0 | n > 0}, where the property holds for L(M>) but not for L(Mj). So, Ly is also undecidable. Ly = {(M,w,q) | M on input w reaches state ¢ in exactly 100 steps} « This is actually a property of Turing machine and not its language. Obviously this is a non-trivial property (but of TM and not its language and hence Rice's theorem is not applicable). Here, we have to check if the given TM on given input w reaches state g in exactly 100 steps - certainly decidable as we just need to monitor the working of Turing machine for 100 steps which should happen in a finite amount of time. But if instead of 100 steps the question is modified to reaching state g ever, then the problem becomes state reachability problem and there is no guarantee that we can answer this problem in finite amount of time (we can answer “yes” but not necessarily “no”), and the problem becomes undecidable (but is still semi-decidable). So Alis correct.","libVersion":"0.2.3","langs":"eng"}