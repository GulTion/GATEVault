{"path":"Revision/TS/ZealTS/COA/media/Pasted image 20231219174510.png","text":"Consider a 10-stage pipeline in which every stage of the original MIPS 5-stage pipeline discussed in class has been split into two (for example, IF split into IF1 and IF2, ID split into ID1 and ID2 and so on). The only catch is that, for data forwarding, data are forwarded from the end of a pair of stages to the beginning of the two stages where they are needed. For example, data are forwarded from the output of the second EX stage (and the second MEM stage) to the input of the first EX stage. Assume that in the original 5-stage pipeline, the longest stage requires 1.8 ns and the 10-stage pipeline splits all the stages in the 5-stage pipeline into half. Also, assume that each pipeline register incurs a delay of 0.2 ns. Consider the following code sequence executing on the 10-stage pipeline with full forwarding hardware: LOAD R1, 8(R2) // Rl —MR2 + 8] ADD RS, R4, R3 // RS —R4+R3 SUBR6, R, R2 // R6 —R1+R2 STORE R7, 16(R6) // R7 — MIR6 + 16] How long (in nanoseconds) does it take for the 10-stage pipeline to execute this code sequence?","libVersion":"0.2.3","langs":"eng"}