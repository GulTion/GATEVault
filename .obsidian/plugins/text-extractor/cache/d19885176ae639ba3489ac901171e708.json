{"path":"Revision/TS/ZealTS/OS/media/Pasted image 20231210121734.png","text":"Answer: (b, c) Solution: Priority inversion is a common pitfall in designing a scheduler with priorities. Consider a thread manager that implements a preemptive, priority scheduling policy. Let's assume we have three threads, T1, T2, and T3, and threads T1 and T3 share a lock 1 that serializes references to a shared resource. Thread T1 has a low priority (1), thread T2 has a medium priority (2), and thread T3 has a high priority (3). Let's assume that T2 and T3 are not runnable; for example, they are waiting for an I/O operation to complete. The scheduler will schedule T1, and T1 acquires lock 1. Now the 1/0 operation completes, and the I/O interrupt handler notifies T2 and T3. The scheduler chooses T3 because it has the highest priority. T3 runs for a short time until it tries to acquire lock 1, but because T1 already holds that lock, T3 must wait. Because T2 is runnable and has higher priority than T1, the thread scheduler will select T2. T2 can compute indefinitely; when T2's time quantum runs out, the scheduler will find two threads runnable: T1 and T2. It will select T2 because T2 has a higher priority than T1. As long as T2 doesn't call wait, T2 will keep the processor. As long as T2 is runnable, the scheduler won't run T1, and thus T1 will not be able to release the lock and T3, the high priority thread, will wait indefinitely. This undesirable phenomenon is known as priority inversion. So, any middle priority thread will lead to priority inversion so correct answer is (b) and (Â©","libVersion":"0.2.3","langs":"eng"}